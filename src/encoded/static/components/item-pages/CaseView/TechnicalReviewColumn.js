'use strict';

import React, { useMemo, useCallback, useRef, useState } from 'react';
import _ from 'underscore';
import Popover  from 'react-bootstrap/esm/Popover';
import ReactTooltip from 'react-tooltip';
import { PatchItemsProgress } from './../../util/PatchItemsProgress';
import { LocalizedTime } from '@hms-dbmi-bgm/shared-portal-components/es/components/ui/LocalizedTime';


export const TechnicalReviewColumn = React.memo(function TechnicalReviewColumn(props){
    const { result, setOpenPopoverData, unsavedTechnicalReviewForResult, setTechnicalReviewForVSUUID } = props;
    const {
        uuid: vsUUID,
        technical_review: savedTechnicalReview = null
    } = result;
    const {
        call: savedCall,
        classification: savedClassification,
        // The following 2 properties are generated by backend and not user-editable -
        date_initial_call_made: savedInitialCallDate,
        initial_call_made_by: { display_title: savedInitialCallAuthorName } = {} // Unlikely to be visible to most people.
    } = savedTechnicalReview || {};
    const {
        call: unsavedCall,
        classification: unsavedClassification,
        // TODO (?):
        // notes: unsavedNotes
    } = unsavedTechnicalReviewForResult || {}; 

    const callTrueButtonRef = useRef(null);
    const callFalseButtonRef = useRef(null);
    const notesButtonRef = useRef(null);



    const handleOpenDropdownCall = useCallback(function handleOpenDropdownCall(){

        const opts = [
            // TODO: Add... onClick-related stuff/data.
            ["Present"],
            ["Low Coverage"],
            ["Low Allelic Fraction"],
            ["Low Mapping Quality"],
            ["Strand Bias"],
            ["Mendelian Error"],
            ["Other"]
        ];

        function renderDropdownItem([ optionName ], i){
            function handleClick(e){
                if (savedCall === true && savedClassification === optionName) {
                    // Delete on PATCH/save, unless unsaved is something else, in which case reset unsaved for this vsUUID.
                    setTechnicalReviewForVSUUID(vsUUID, typeof unsavedTechnicalReviewForResult === "undefined" ? null : undefined);
                } else if (unsavedCall === true && unsavedClassification === optionName) { // TODO make sure no unsaved notes that'd be lost
                    // Unset
                    setTechnicalReviewForVSUUID(vsUUID, undefined);
                } else {
                    setTechnicalReviewForVSUUID(vsUUID, {
                        // Preserve any saved or unsaved notes, as well (if we use linkTo for notes, will need to re-think this)
                        ...savedTechnicalReview,
                        ...unsavedTechnicalReviewForResult,
                        "call": true,
                        "classification": optionName
                    });
                }
                setOpenPopoverData(null);
            }

            const isUnsavedSelected = unsavedCall === true && unsavedClassification === optionName;
            const isSavedSelected = savedCall === true && savedClassification === optionName;
            const isSetToRemove = isSavedSelected && (unsavedTechnicalReviewForResult === null || (unsavedClassification && !isUnsavedSelected));

            const btnClass = (
                "dropdown-item" +
                (isUnsavedSelected || (isSavedSelected && !isSetToRemove) ? " bg-success text-white" : "") +
                (isSetToRemove ? " bg-light text-secondary" : "")
            );

            return (
                <button type="button" className={btnClass} key={i} onClick={handleClick}>
                    { optionName }
                    { isUnsavedSelected ?
                        <i className="icon icon-asterisk fas ml-08" data-tip="Not Saved" />
                        : isSetToRemove ?
                            <i className="icon icon-minus-circle fas ml-08 text-danger" data-tip="Will be unset" />
                            : null }
                </button>
            );
        }

        setOpenPopoverData({
            "uuid": vsUUID,
            "call": true,
            "ref": callTrueButtonRef,
            "jsx": (
                <Popover id="technical-review-popover">
                    <Popover.Title className="m-0 text-600 text-uppercase" as="h5">Present</Popover.Title>
                    <Popover.Content className="px-0 py-1">
                        { opts.slice(0,1).map(renderDropdownItem) }
                    </Popover.Content>
                    <Popover.Title className="m-0 text-600 text-uppercase border-top" as="h5">Present - with concerns</Popover.Title>
                    <Popover.Content className="px-0 py-1">
                        { opts.slice(1).map(renderDropdownItem) }
                    </Popover.Content>
                </Popover>
            )
        });
        setTimeout(ReactTooltip.rebuild, 10);
    }, [ result, unsavedTechnicalReviewForResult ]);



    const handleOpenDropdownNoCall = useCallback(function(){

        const opts = [
            // TODO: Add... onClick-related stuff/data.
            ["Recurrent Artifact"],
            ["Low Coverage"],
            ["Low Allelic Fraction"],
            ["Low Mapping Quality"],
            ["Strand Bias"],
            ["Mendelian Error"],
            ["Other"]
        ];

        function renderDropdownItem([ optionName ], i){
            function handleClick(e){
                if (savedCall === false && savedClassification === optionName) {
                    // Delete on PATCH/save, unless unsaved is something else, in which case reset unsaved for this vsUUID.
                    setTechnicalReviewForVSUUID(vsUUID, typeof unsavedTechnicalReviewForResult === "undefined" ? null : undefined);
                } else if (unsavedCall === false && unsavedClassification === optionName) {
                    // Unset
                    setTechnicalReviewForVSUUID(vsUUID, undefined);
                } else {
                    setTechnicalReviewForVSUUID(vsUUID, { "call": false, "classification": optionName });
                }
                setOpenPopoverData(null);
            }

            const isUnsavedSelected = unsavedCall === false && unsavedClassification === optionName;
            const isSavedSelected = savedCall === false && savedClassification === optionName;
            const isSetToRemove = isSavedSelected && (unsavedTechnicalReviewForResult === null || (unsavedClassification && !isUnsavedSelected));

            const btnClass = (
                "dropdown-item" +
                (isUnsavedSelected || (isSavedSelected && !isSetToRemove) ? " bg-danger text-white" : "") +
                (isSetToRemove ? " bg-light text-secondary" : "")
            );

            return (
                <button type="button" className={btnClass} key={i} onClick={handleClick}>
                    { optionName }
                    { isUnsavedSelected ?
                        <i className="icon icon-asterisk fas ml-08" data-tip="Not Saved" />
                        : isSetToRemove ?
                            <i className="icon icon-minus-circle fas ml-08 text-danger" data-tip="Will be unset" />
                            : null }
                </button>
            );
        }

        setOpenPopoverData({
            "uuid": vsUUID,
            "call": false,
            "ref": callFalseButtonRef,
            "jsx": (
                <Popover id="technical-review-popover">
                    <Popover.Title className="m-0 text-600 text-uppercase" as="h5">No Call</Popover.Title>
                    <Popover.Content className="px-0 py-1">
                        { opts.map(renderDropdownItem) }
                    </Popover.Content>
                </Popover>
            )
        });
        setTimeout(ReactTooltip.rebuild, 10);
    }, [ result, unsavedTechnicalReviewForResult ]);



    const handleOpenNotesPopover = useCallback(function(){
        setOpenPopoverData({
            "uuid": vsUUID,
            "call": null,
            "ref": notesButtonRef,
            "jsx": (
                <Popover id="technical-review-popover">
                    <Popover.Title className="m-0 text-600" as="h5">Technical Review Note</Popover.Title>
                    <Popover.Content className="p-2">
                        { savedInitialCallDate ?
                            <div className="small">
                                Call Made: <LocalizedTime timestamp={savedInitialCallDate} />
                                { savedInitialCallAuthorName ? (" by " + savedInitialCallAuthorName) : null }
                            </div>
                            : null }
                        <h6>Variant Call</h6>
                        { !savedTechnicalReview ? <em>Nothing saved</em> :
                            <div className={"d-inline-block px-3 py-1 rounded" + (
                                savedCall === true ? " bg-success text-white"
                                    : savedCall === false ? " bg-danger text-white" : "" )}>
                                { savedCall === true ? "Call - " : savedCall === false ? "No Call - " : "" }
                                { savedClassification }
                            </div>
                        }
                        <h6>Technical Notes</h6>
                        <textarea className="form-control" rows={5} disabled>Coming soon...</textarea>
                    </Popover.Content>
                </Popover>
            )
        });
    }, [ result, unsavedTechnicalReviewForResult ]);

    return (
        <div className="w-100 d-flex align-items-center justify-content-around text-truncate py-1">

            <button type="button" className="btn btn-link p-0 text-decoration-none" onClick={handleOpenDropdownCall} ref={callTrueButtonRef}
                data-call="true" data-technical-review="true">
                <i className={"icon icon-2x icon-fw fas icon-check text-" + (
                    (unsavedCall === true || (savedCall === true && typeof unsavedTechnicalReviewForResult === 'undefined' )) ? "success"
                        : (savedCall === true ? "secondary" : "muted")
                    )} />
                { unsavedCall === true || (unsavedTechnicalReviewForResult === null && savedCall === true) ?
                    <span className="text-danger position-absolute" data-tip="Not Saved">*</span>
                    : null }
            </button>

            <button type="button" className="btn btn-link p-0 text-decoration-none" onClick={handleOpenDropdownNoCall} ref={callFalseButtonRef}
                data-call="false" data-technical-review="true">
                <i className={"icon icon-2x icon-fw fas icon-times text-" + (
                    (unsavedCall === false || (savedCall === false && typeof unsavedTechnicalReviewForResult === 'undefined')) ? "danger"
                        : (savedCall === false ? "secondary" : "muted")
                    )} />
                { unsavedCall === false || (unsavedTechnicalReviewForResult === null && savedCall === false) ?
                    <span className="text-danger position-absolute" data-tip="Not Saved">*</span>
                    : null }
            </button>

            <button type="button" className="btn btn-link p-0 text-decoration-none" onClick={handleOpenNotesPopover} ref={notesButtonRef} data-technical-review="true">
                <i className={"icon icon-2x icon-fw fas icon-sticky-note text-muted"}  />
            </button>

        </div>
    );

});


export function SaveTechnicalReviewButton(props){
    const { unsavedTechnicalReview, resetUnsavedTechnicalReview, haveEditPermission, patchItems, isPatching } = props;

    const unsavedTechnicalReviewVSUUIDs = Object.keys(unsavedTechnicalReview);
    const unsavedTechnicalReviewVSUUIDsLen = unsavedTechnicalReviewVSUUIDs.length;

    const saveProcess = useCallback(function(){
        const payloads = [];
        unsavedTechnicalReviewVSUUIDs.forEach(function(vsUUID){
            const unsavedTechnicalReviewForVS = unsavedTechnicalReview[vsUUID];
            const payload = [ "/" + vsUUID, {} ];
            if (unsavedTechnicalReviewForVS === null) {
                payload[0] += "?delete_fields=technical_review";
            } else {
                payload[1].technical_review = unsavedTechnicalReviewForVS;
            }
            payloads.push(payload);
        });
        patchItems(payloads, function(countCompleted, patchErrors){
            if (countCompleted === unsavedTechnicalReviewVSUUIDsLen) {
                resetUnsavedTechnicalReview();
            }
        });
    }, [ unsavedTechnicalReview ]);

    const disabled = !haveEditPermission || isPatching || unsavedTechnicalReviewVSUUIDsLen === 0;

    return (
        <button type="button" className="btn btn-primary" disabled={disabled} onClick={saveProcess}>
            Update technical review for { unsavedTechnicalReviewVSUUIDsLen } samples
        </button>
    );

}

export class TechnicalReviewController extends React.PureComponent {

    constructor(props) {
        super(props);
        this.setTechnicalReviewForVSUUID = this.setTechnicalReviewForVSUUID.bind(this);
        this.resetUnsavedTechnicalReview = this.resetUnsavedTechnicalReview.bind(this);
        this.state = {
            "unsavedTechnicalReview": {}
        };
    }

    setTechnicalReviewForVSUUID(vsUUID, technicalReview) {
        this.setState(function({ unsavedTechnicalReview: existingTechReview }){
            // "undefined" means remove from state.unsavedTechnicalReview, "null" means to keep in state to queue for deletion in PATCH.
            if (typeof technicalReview === "undefined") {
                if (typeof existingTechReview[vsUUID] !== "undefined") {
                    return { "unsavedTechnicalReview": _.omit(existingTechReview, vsUUID) };
                }
                return null;
            }
            return { "unsavedTechnicalReview": { ...existingTechReview, [vsUUID]: technicalReview } };
        });
    }

    resetUnsavedTechnicalReview() {
        this.setState({ "unsavedTechnicalReview": {} });
    }

    render(){
        const { children, ...passProps } = this.props;
        const { unsavedTechnicalReview } = this.state;
        const childProps = {
            ...passProps,
            unsavedTechnicalReview,
            "setTechnicalReviewForVSUUID": this.setTechnicalReviewForVSUUID,
            "resetUnsavedTechnicalReview": this.resetUnsavedTechnicalReview
        };
        return React.Children.map(children, function(child){
            if (!React.isValidElement(child) || typeof child.type === "string") {
                return child;
            }
            return React.cloneElement(child, childProps);
        });
    }

}